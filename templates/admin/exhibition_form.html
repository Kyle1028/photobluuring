<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/png" href="/static/logo-icon.png" />
    <title>{% if mode == 'create' %}{{ _('å»ºç«‹å±•è¦½') }}{% else %}{{ _('ç·¨è¼¯å±•è¦½') }}{% endif %} - å•†æ™¯ Bizeview</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Microsoft JhengHei", sans-serif;
            background: #f5f7fa;
            min-height: 100vh;
        }
        
        /* å°èˆªåˆ— */
        .navbar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            background: white;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            padding: 15px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .navbar-brand {
            font-size: 20px;
            font-weight: 600;
            color: #333;
        }
        
        .navbar-brand a {
            text-decoration: none;
            color: inherit;
            display: inline-block;
        }
        
        .navbar-brand img {
            height: 40px;
            vertical-align: middle;
        }
        
        .navbar-user {
            display: flex;
            align-items: center;
            gap: 20px;
        }
        
        .user-email {
            color: #666;
            font-size: 14px;
        }
        
        .nav-link {
            background: #667eea;
            color: white;
            text-decoration: none;
            font-size: 14px;
            font-weight: 600;
            padding: 10px 20px;
            border-radius: 6px;
            transition: all 0.3s;
            box-shadow: 0 2px 4px rgba(102, 126, 234, 0.2);
        }
        
        .nav-link:hover {
            background: #5568d3;
            box-shadow: 0 4px 8px rgba(102, 126, 234, 0.3);
            transform: translateY(-1px);
        }
        
        .btn-logout {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            text-decoration: none;
            transition: all 0.3s;
        }
        
        .btn-logout:hover {
            background: #c0392b;
        }
        
        /* ä¸»å…§å®¹å€ */
        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 100px 20px 40px 20px; /* ä¸Šæ–¹ padding å¢åŠ ä»¥é©æ‡‰å›ºå®šå°èˆªæ¬„ */
        }
        
        .form-card {
            background: white;
            padding: 40px;
            border-radius: 15px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
        }
        
        .form-header {
            margin-bottom: 30px;
        }
        
        .form-header h1 {
            color: #333;
            font-size: 28px;
            margin-bottom: 10px;
        }
        
        .form-group {
            margin-bottom: 25px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 8px;
            color: #333;
            font-weight: 600;
            font-size: 14px;
        }
        
        .form-group input[type="text"],
        .form-group input[type="date"],
        .form-group textarea {
            width: 100%;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            font-family: inherit;
            transition: all 0.3s;
        }
        
        .form-group input:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        .form-group textarea {
            min-height: 120px;
            resize: vertical;
        }
        
        .form-group input[type="file"] {
            padding: 8px;
        }
        
        .form-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            margin-right: 8px;
            cursor: pointer;
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
        }
        
        .form-actions {
            display: flex;
            gap: 15px;
            margin-top: 30px;
            padding-top: 30px;
            border-top: 1px solid #e0e0e0;
        }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            text-decoration: none;
            transition: all 0.3s;
        }
        
        .btn-primary {
            background: #667eea;
            color: white;
        }
        
        .btn-primary:hover {
            background: #5568d3;
        }
        
        .btn-secondary {
            background: #95a5a6;
            color: white;
        }
        
        .btn-secondary:hover {
            background: #7f8c8d;
        }
        
        .flash-messages {
            margin-bottom: 20px;
        }
        
        .flash-message {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 10px;
        }
        
        .flash-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .flash-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .help-text {
            font-size: 12px;
            color: #999;
            margin-top: 5px;
        }
        
        /* æ‰‹æ©Ÿç‰ˆéŸ¿æ‡‰å¼è¨­è¨ˆ */
        @media (max-width: 768px) {
            .navbar {
                padding: 10px 15px !important;
                flex-wrap: wrap;
            }
            
            .navbar-brand {
                font-size: 16px !important;
            }
            
            .navbar-brand img {
                height: 32px !important;
            }
            
            .navbar-user {
                gap: 10px !important;
                flex-wrap: wrap;
            }
            
            .user-email {
                font-size: 12px !important;
                max-width: 120px;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
            }
            
            .container {
                padding: 90px 10px 20px 10px; /* å¢åŠ é ‚éƒ¨ padding é¿å…è¢«å°èˆªæ¬„é®æ“‹ */
            }
            
            .form-card {
                padding: 25px 15px;
            }
            
            .form-header h1 {
                font-size: 24px;
            }
            
            .form-actions {
                flex-direction: column;
                gap: 10px;
            }
            
            .form-actions .btn {
                width: 100%;
            }
        }
        
        @media (max-width: 480px) {
            .navbar {
                padding: 8px 10px !important;
            }
            
            .navbar-brand img {
                height: 28px !important;
            }
            
            .user-email {
                display: none !important;
            }
            
            .container {
                padding: 80px 5px 15px 5px; /* å¢åŠ é ‚éƒ¨ padding é¿å…è¢«å°èˆªæ¬„é®æ“‹ */
            }
            
            .form-card {
                padding: 20px 10px;
            }
            
            .form-header h1 {
                font-size: 20px;
            }
            
            textarea {
                min-height: 100px;
            }
        }
    </style>
</head>
<body>
    <!-- å°èˆªåˆ— -->
    <nav class="navbar">
        <div class="navbar-brand">
            <a href="{{ url_for('index') }}">
                <img src="/static/logo.png" alt="å•†æ™¯ Bizeview" style="height: 40px; vertical-align: middle;">
            </a>
        </div>
        <div class="navbar-user">
            {% include '_language_switcher.html' %}
            <span class="user-email">ğŸ‘¤ {{ current_user.email }}</span>
            {% include '_settings_dropdown.html' %}
        </div>
    </nav>

    <!-- ä¸»å…§å®¹å€ -->
    <div class="container">
        <div class="form-card">
            <div class="form-header">
                <h1>{% if mode == 'create' %}{{ _('å»ºç«‹æ–°å±•è¦½') }}{% else %}{{ _('ç·¨è¼¯å±•è¦½') }}{% endif %}</h1>
            </div>

            <!-- Flash è¨Šæ¯ -->
            {% with messages = get_flashed_messages(with_categories=true) %}
                {% if messages %}
                    <div class="flash-messages">
                        {% for category, message in messages %}
                            <div class="flash-message flash-{{ category }}">
                                {{ message }}
                            </div>
                        {% endfor %}
                    </div>
                {% endif %}
            {% endwith %}

            <!-- è¡¨å–® -->
            <form method="POST" enctype="multipart/form-data">
                <div class="form-group">
                    <label for="title">{{ _('å±•è¦½æ¨™é¡Œ') }} *</label>
                    <input type="text" id="title" name="title" required 
                           value="{{ exhibition.title if exhibition else '' }}">
                </div>

                <div class="form-group">
                    <label for="description">{{ _('å±•è¦½æè¿°') }}</label>
                    <textarea id="description" name="description" 
                              placeholder="{{ _('è¼¸å…¥å±•è¦½çš„è©³ç´°æè¿°...') }}">{{ exhibition.description if exhibition else '' }}</textarea>
                </div>

                <div class="form-group">
                    <label for="start_date">{{ _('é–‹å§‹æ—¥æœŸ') }}</label>
                    <input type="date" id="start_date" name="start_date" 
                           value="{{ exhibition.start_date.strftime('%Y-%m-%d') if exhibition and exhibition.start_date else '' }}">
                </div>

                <div class="form-group">
                    <label for="end_date">{{ _('çµæŸæ—¥æœŸ') }}</label>
                    <input type="date" id="end_date" name="end_date" 
                           value="{{ exhibition.end_date.strftime('%Y-%m-%d') if exhibition and exhibition.end_date else '' }}">
                </div>

                <div class="form-group">
                    <label for="cover_image">{{ _('å°é¢åœ–ç‰‡') }}</label>
                    <input type="file" id="cover_image" name="cover_image" accept="image/*">
                    <div class="help-text">{{ _('æ”¯æ´ JPGã€PNGã€WEBP æ ¼å¼') }}</div>
                    {% if exhibition and exhibition.cover_image %}
                        <div class="help-text" style="margin-top: 10px;">
                            {{ _('ç›®å‰å°é¢ï¼š') }}<a href="{{ url_for('exhibition_cover', exhibition_public_id=exhibition.public_id) }}" target="_blank">{{ _('æŸ¥çœ‹') }}</a>
                        </div>
                    {% endif %}
                </div>

                <!-- æ¨“å±¤å¹³é¢åœ–è¨­å®šï¼ˆç›®å‰å…ˆæ”¯æ´ F001ï¼Œä¸€å€‹å±•è¦½å¯ä¹‹å¾Œå†é€éç®¡ç†é æ–°å¢æ›´å¤šæ¨“å±¤ï¼‰ -->
                <div class="form-group">
                    <label>{{ _('æ¨“å±¤å¹³é¢åœ–ï¼ˆF001ï¼‰') }}</label>
                    <input type="file" id="floor_image_f001" name="floor_image_f001" accept="image/*">
                    <div class="help-text">
                        {{ _('é¸æ“‡æ­¤å±•è¦½ç¬¬ä¸€å±¤çš„å¹³é¢åœ–ï¼ˆå¯é¸ï¼‰ï¼Œç³»çµ±æœƒä¾å¯¦éš›å°ºå¯¸èˆ‡ç¶²æ ¼å¤§å°åˆ‡æˆå€åŸŸ C000001...') }}
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(3, minmax(0, 1fr)); gap: 10px; margin-top: 10px;">
                        <div>
                            <label for="floor_width_f001">{{ _('å¯¦éš›å¯¬åº¦ï¼ˆå…¬å°ºï¼‰') }}</label>
                            <input type="number" id="floor_width_f001" name="floor_width_f001" min="0" step="0.01"
                                   value="{% if exhibition and exhibition.floors %}{% for floor in exhibition.floors %}{% if floor.floor_code == 'F001' %}{{ floor.width_meters or '' }}{% endif %}{% endfor %}{% endif %}">
                        </div>
                        <div>
                            <label for="floor_height_f001">{{ _('å¯¦éš›é«˜åº¦ï¼ˆå…¬å°ºï¼‰') }}</label>
                            <input type="number" id="floor_height_f001" name="floor_height_f001" min="0" step="0.01"
                                   value="{% if exhibition and exhibition.floors %}{% for floor in exhibition.floors %}{% if floor.floor_code == 'F001' %}{{ floor.height_meters or '' }}{% endif %}{% endfor %}{% endif %}">
                        </div>
                        <div>
                            <label for="floor_grid_f001">{{ _('ç¶²æ ¼å¤§å°ï¼ˆå…¬å°ºï¼Œé è¨­ 1ï¼‰') }}</label>
                            <input type="number" id="floor_grid_f001" name="floor_grid_f001" min="0.1" step="0.1"
                                   value="{% if exhibition and exhibition.floors %}{% for floor in exhibition.floors %}{% if floor.floor_code == 'F001' %}{{ floor.grid_size or 1 }}{% endif %}{% endfor %}{% else %}1{% endif %}">
                        </div>
                    </div>
                    {% if exhibition and exhibition.floors %}
                        <div class="help-text" style="margin-top: 10px;">
                            {{ _('æ­¤å±•è¦½ç›®å‰å·²æœ‰ä¸‹åˆ—æ¨“å±¤ï¼š') }}
                            {% for floor in exhibition.floors %}
                                <span style="margin-right: 8px;">{{ floor.floor_code }}</span>
                            {% endfor %}
                        </div>
                        {% if mode == 'edit' %}
                        <div style="margin-top: 10px;">
                            <label for="selectionFloor" style="font-size: 13px; font-weight: 600; display: block; margin-bottom: 4px;">
                                {{ _('é¸æ“‡è¦åœˆé¸ç¯„åœçš„æ¨“å±¤') }}
                            </label>
                            <select id="selectionFloor" style="padding: 8px 10px; border-radius: 8px; border: 1px solid #ddd; font-size: 14px;">
                                {% for floor in exhibition.floors %}
                                    <option value="{{ floor.floor_code }}" {% if loop.first %}selected{% endif %}>
                                        {{ floor.floor_code }}
                                    </option>
                                {% endfor %}
                            </select>
                            <div class="help-text" style="margin-top: 4px;">
                                {{ _('é¸æ“‡æ¨“å±¤å¾Œï¼Œä¸‹æ–¹åœˆé¸å·¥å…·æœƒè¼‰å…¥è©²æ¨“å±¤çš„å¹³é¢åœ–èˆ‡ç¶²æ ¼è¨­å®š') }}
                            </div>
                        </div>
                        <input type="hidden" id="selectionFloorCode" name="selection_floor_code" value="{{ (exhibition.floors|first).floor_code }}">
                        {% endif %}
                    {% endif %}
                    
                    <!-- åœˆé¸å±•è¦½ç¯„åœå·¥å…· -->
                    <div id="areaSelectionSection" style="margin-top: 20px; display: none;">
                        <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 10px; flex-wrap: wrap;">
                            <div style="display: flex; gap: 5px;">
                                <button type="button" id="rectToolBtn" class="btn btn-primary" style="padding: 8px 16px;">
                                    {{ _('çŸ©å½¢é¸æ“‡') }}
                                </button>
                                <button type="button" id="polygonToolBtn" class="btn btn-secondary" style="padding: 8px 16px;">
                                    {{ _('å¤šé‚Šå½¢é¸æ“‡') }}
                                </button>
                            </div>
                            <button type="button" id="undoLastPointBtn" class="btn btn-secondary" style="padding: 8px 16px; display: none;">
                                {{ _('æ’¤éŠ·æœ€å¾Œä¸€é»') }}
                            </button>
                            <button type="button" id="clearSelectionBtn" class="btn btn-secondary" style="padding: 8px 16px; display: none;">
                                {{ _('æ¸…é™¤åœˆé¸') }}
                            </button>
                            <button type="button" id="finishSelectionBtn" class="btn btn-primary" style="padding: 8px 16px; display: none;">
                                {{ _('å®Œæˆç•¶å‰å€åŸŸ') }}
                            </button>
                            <button type="button" id="finishAllBtn" class="btn btn-primary" style="padding: 8px 16px; display: none;">
                                {{ _('å®Œæˆæ‰€æœ‰åœˆé¸') }}
                            </button>
                            <span id="selectionStatus" style="color: #666; font-size: 14px;"></span>
                        </div>
                        <div id="selectedAreasList" style="margin-top: 10px; display: none;">
                            <div style="font-weight: 600; margin-bottom: 5px;">{{ _('å·²é¸æ“‡çš„å€åŸŸ') }}ï¼š</div>
                            <div id="selectedAreasTags" style="display: flex; flex-wrap: wrap; gap: 5px;"></div>
                        </div>
                        <div style="position: relative; border: 2px solid #ddd; border-radius: 8px; background: #f8f9fa; overflow: auto; max-height: 80vh;">
                            <canvas id="floorplanCanvas" style="display: block; cursor: crosshair;"></canvas>
                            <div id="canvasOverlay" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;"></div>
                        </div>
                        <div class="help-text" style="margin-top: 10px;">
                            <span id="helpText">{{ _('é¸æ“‡å·¥å…·ï¼šçŸ©å½¢é¸æ“‡ï¼ˆæ‹–æ‹½ç¹ªè£½çŸ©å½¢ï¼‰æˆ–å¤šé‚Šå½¢é¸æ“‡ï¼ˆé»æ“Šå¤šå€‹é»ï¼‰ã€‚åœˆé¸å€åŸŸå¤–çš„ç¶²æ ¼å°‡è¢«æ¨™è¨˜ç‚ºç„¡æ•ˆã€‚') }}</span>
                        </div>
                        <input type="hidden" id="selectionPolygon" name="selection_polygon" value="">
                    </div>
                </div>

                <div class="form-group">
                    <div class="checkbox-group">
                        <input type="checkbox" id="is_published" name="is_published" 
                               {% if exhibition and exhibition.is_published %}checked{% endif %}>
                        <label for="is_published" style="margin: 0; font-weight: normal; cursor: pointer;">
                            {{ _('ç«‹å³ç™¼å¸ƒï¼ˆå…¬é–‹å±•è¦½ï¼‰') }}
                        </label>
                    </div>
                </div>

                <div class="form-actions">
                    <button type="submit" class="btn btn-primary">
                        {% if mode == 'create' %}{{ _('å»ºç«‹å±•è¦½') }}{% else %}{{ _('æ›´æ–°å±•è¦½') }}{% endif %}
                    </button>
                    <a href="{{ url_for('admin.exhibitions_list') }}" class="btn btn-secondary">{{ _('å–æ¶ˆ') }}</a>
                </div>
            </form>
        </div>
    </div>

    <script>
        // åœˆé¸å±•è¦½ç¯„åœåŠŸèƒ½
        (function() {
            const floorImageInput = document.getElementById('floor_image_f001');
            const floorWidthInput = document.getElementById('floor_width_f001');
            const floorHeightInput = document.getElementById('floor_height_f001');
            const floorGridInput = document.getElementById('floor_grid_f001');
            const areaSelectionSection = document.getElementById('areaSelectionSection');
            const rectToolBtn = document.getElementById('rectToolBtn');
            const polygonToolBtn = document.getElementById('polygonToolBtn');
            const undoLastPointBtn = document.getElementById('undoLastPointBtn');
            const clearSelectionBtn = document.getElementById('clearSelectionBtn');
            const finishSelectionBtn = document.getElementById('finishSelectionBtn');
            const selectionStatus = document.getElementById('selectionStatus');
            const helpText = document.getElementById('helpText');
            const canvas = document.getElementById('floorplanCanvas');
            const selectionPolygonInput = document.getElementById('selectionPolygon');
            
            const finishAllBtn = document.getElementById('finishAllBtn');
            const selectedAreasList = document.getElementById('selectedAreasList');
            const selectedAreasTags = document.getElementById('selectedAreasTags');
            
            let ctx = null;
            let floorplanImage = null;
            let selectionMode = null; // 'rect' æˆ– 'polygon'
            let isSelecting = false;
            let polygonPoints = [];
            let rectStartPoint = null; // çŸ©å½¢èµ·å§‹é»
            let rectEndPoint = null; // çŸ©å½¢çµæŸé»
            let isDrawingRect = false; // æ˜¯å¦æ­£åœ¨ç¹ªè£½çŸ©å½¢
            let selectedAreas = []; // å·²å®Œæˆçš„é¸æ“‡å€åŸŸåˆ—è¡¨ [{type: 'rect'|'polygon', points: [...]}, ...]
            let gridData = null; // { cols, rows, cellWidth, cellHeight }
            const selectionFloorSelect = document.getElementById('selectionFloor');
            const selectionFloorHidden = document.getElementById('selectionFloorCode');
            let currentSelectionFloorMeta = null; // ç›®å‰åœˆé¸ä½¿ç”¨çš„æ¨“å±¤å°ºå¯¸è³‡è¨Šï¼ˆä¸å½±éŸ¿è¡¨å–®æ¬„ä½ï¼‰

            // å¾Œç«¯æä¾›çš„æ¨“å±¤è³‡æ–™ï¼ˆä»£ç¢¼ / å°ºå¯¸ / ç¶²æ ¼ / åœ–ç‰‡ URLï¼‰
            const floorsData = [
            {% if exhibition and exhibition.floors %}
                {% for floor in exhibition.floors %}
                {
                    code: "{{ floor.floor_code }}",
                    width: {{ floor.width_meters or 0 }},
                    height: {{ floor.height_meters or 0 }},
                    gridSize: {{ floor.grid_size or 1 }},
                    imageUrl: "{{ url_for('exhibition_floor_image', exhibition_public_id=exhibition.public_id, floor_code=floor.floor_code) }}"
                }{% if not loop.last %},{% endif %}
                {% endfor %}
            {% endif %}
            ];

            // æ¯å€‹æ¨“å±¤ç›®å‰å·²å•Ÿç”¨çš„æ ¼å­ï¼ˆç”¨ä¾†åœ¨å‰›é€²ç·¨è¼¯é æ™‚é‚„åŸåŸæœ¬ç¯„åœï¼‰
            const floorCellsMap = {
            {% if exhibition and exhibition.floors %}
                {% for floor in exhibition.floors %}
                "{{ floor.floor_code }}": [
                    {% for cell in floor.cells|sort(attribute='row')|sort(attribute='col') %}
                    { row: {{ cell.row }}, col: {{ cell.col }}, is_active: {{ 'true' if cell.is_active else 'false' }} }{% if not loop.last %},{% endif %}
                    {% endfor %}
                ]{% if not loop.last %},{% endif %}
                {% endfor %}
            {% endif %}
            };

            function loadFloorForSelection(code) {
                const data = floorsData.find(f => f.code === code);
                if (!data) return;

                if (selectionFloorHidden) {
                    selectionFloorHidden.value = data.code;
                }

                // åªçµ¦åœˆé¸é¡¯ç¤ºç”¨ï¼ŒçœŸæ­£çš„æ¨“å±¤å°ºå¯¸é‚„æ˜¯ä»¥å¾Œç«¯ DB ç‚ºæº–
                currentSelectionFloorMeta = {
                    width: data.width || 0,
                    height: data.height || 0,
                    gridSize: data.gridSize || 1
                };

                const img = new Image();
                img.onload = function() {
                    floorplanImage = img;

                    // ç­‰å¾…ä¸‹ä¸€å¹€ï¼Œç¢ºä¿å®¹å™¨å°ºå¯¸å·²è¨ˆç®—
                    requestAnimationFrame(function() {
                        const container = canvas.parentElement;
                        const containerRect = container.getBoundingClientRect();
                        const containerWidth = Math.max(containerRect.width - 20, 800); // æœ€å°å¯¬åº¦ 800px
                        const containerHeight = Math.max(window.innerHeight * 0.6, 600); // æœ€å°é«˜åº¦ 600px

                        const scaleX = containerWidth / img.width;
                        const scaleY = containerHeight / img.height;
                        const scale = Math.min(scaleX, scaleY);

                        const displayWidth = Math.round(img.width * scale);
                        const displayHeight = Math.round(img.height * scale);

                        canvas.width = displayWidth;
                        canvas.height = displayHeight;
                        canvas.style.width = displayWidth + 'px';
                        canvas.style.height = displayHeight + 'px';

                        canvas.dataset.scale = scale;
                        canvas.dataset.originalWidth = img.width;
                        canvas.dataset.originalHeight = img.height;

                        ctx = canvas.getContext('2d');
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        ctx.drawImage(img, 0, 0, displayWidth, displayHeight);

                        // é‡ç½®åœˆé¸ç‹€æ…‹ï¼ˆæ›æ¨“å±¤æ™‚é‡æ–°åœˆï¼‰
                        selectedAreas = [];
                        polygonPoints = [];
                        rectStartPoint = null;
                        rectEndPoint = null;
                        isDrawingRect = false;
                        selectionPolygonInput.value = '';
                        selectionStatus.textContent = '';
                        selectedAreasTags.innerHTML = '';
                        selectedAreasList.style.display = 'none';
                        finishAllBtn.style.display = 'none';

                        areaSelectionSection.style.display = 'block';
                        updateGrid();
                    });
                };
                img.onerror = function() {
                    console.error('Failed to load floor plan image for', code);
                };
                img.src = data.imageUrl;
            }

            // ç·¨è¼¯æ¨¡å¼åˆå§‹åŒ–ï¼šæœ‰æ¨“å±¤å°±è¼‰å…¥é¸å–çš„é‚£ä¸€å±¤
            if (floorsData.length > 0 && selectionFloorHidden) {
                const initialCode = selectionFloorHidden.value || floorsData[0].code;
                if (selectionFloorSelect) {
                    selectionFloorSelect.value = initialCode;
                    selectionFloorSelect.addEventListener('change', function() {
                        loadFloorForSelection(this.value);
                    });
                }
                loadFloorForSelection(initialCode);
            }
            
            // ç•¶å¹³é¢åœ–ä¸Šå‚³æ™‚ï¼Œé¡¯ç¤ºé è¦½å’Œåœˆé¸å·¥å…·
            floorImageInput.addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (file && file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        const img = new Image();
                        img.onload = function() {
                            floorplanImage = img;
                            
                            // ç­‰å¾…ä¸‹ä¸€å¸§ï¼Œç¢ºä¿å®¹å™¨å°ºå¯¸å·²è¨ˆç®—
                            requestAnimationFrame(function() {
                                // ç²å–å®¹å™¨å°ºå¯¸
                                const container = canvas.parentElement;
                                const containerRect = container.getBoundingClientRect();
                                const containerWidth = Math.max(containerRect.width - 20, 800); // æœ€å°å¯¬åº¦ 800px
                                const containerHeight = Math.max(window.innerHeight * 0.6, 600); // æœ€å°é«˜åº¦ 600px
                                
                                // è¨ˆç®—é©åˆçš„é¡¯ç¤ºå°ºå¯¸ï¼Œç¢ºä¿åœ–ç‰‡å®Œæ•´é¡¯ç¤ºä¸”ä¸è¢«è£å‰ª
                                const scaleX = containerWidth / img.width;
                                const scaleY = containerHeight / img.height;
                                const scale = Math.min(scaleX, scaleY); // é¸æ“‡è¼ƒå°çš„ç¸®æ”¾æ¯”ä¾‹ï¼Œç¢ºä¿å®Œæ•´é¡¯ç¤º
                                
                                // Canvas å…§éƒ¨å°ºå¯¸ = é¡¯ç¤ºå°ºå¯¸ï¼ˆé€™æ¨£åº§æ¨™è½‰æ›å°±ç°¡å–®äº†ï¼‰
                                const displayWidth = Math.round(img.width * scale);
                                const displayHeight = Math.round(img.height * scale);
                                
                                canvas.width = displayWidth;
                                canvas.height = displayHeight;
                                canvas.style.width = displayWidth + 'px';
                                canvas.style.height = displayHeight + 'px';
                                
                                // é€™æ˜¯é‡å°ã€Œæ–°ä¸Šå‚³ã€çš„ F001ï¼Œåœˆé¸ä½¿ç”¨ç•¶å‰è¡¨å–®æ¬„ä½
                                currentSelectionFloorMeta = null;
                                
                                // ä¿å­˜ç¸®æ”¾æ¯”ä¾‹ï¼Œç”¨æ–¼å¾ŒçºŒè¨ˆç®—
                                canvas.dataset.scale = scale;
                                canvas.dataset.originalWidth = img.width;
                                canvas.dataset.originalHeight = img.height;
                                
                                ctx = canvas.getContext('2d');
                                
                                // ç¹ªè£½åœ–ç‰‡ï¼ˆç¸®æ”¾åˆ°é¡¯ç¤ºå°ºå¯¸ï¼‰
                                ctx.drawImage(img, 0, 0, displayWidth, displayHeight);
                                
                                // é¡¯ç¤ºåœˆé¸å€åŸŸ
                                areaSelectionSection.style.display = 'block';
                                
                                // å¦‚æœç¶²æ ¼å¤§å°ç‚ºç©ºï¼Œè¨­ç½®é è¨­å€¼ç‚º 1
                                if (!floorGridInput.value || parseFloat(floorGridInput.value) <= 0) {
                                    floorGridInput.value = '1';
                                }
                                
                                // å¦‚æœæœ‰å¯¬é«˜å’Œç¶²æ ¼å¤§å°ï¼Œç¹ªè£½ç¶²æ ¼
                                updateGrid();
                            });
                        };
                        img.src = event.target.result;
                    };
                    reader.readAsDataURL(file);
                }
            });
            
            // ç•¶å¯¬é«˜æˆ–ç¶²æ ¼å¤§å°æ”¹è®Šæ™‚ï¼Œæ›´æ–°ç¶²æ ¼
            [floorWidthInput, floorHeightInput, floorGridInput].forEach(input => {
                input.addEventListener('input', function () {
                    // é‡å°ã€Œæ–°ä¸Šå‚³ / æ–°è¨­å®šã€çš„ F001ï¼Œç›´æ¥ç”¨è¡¨å–®æ¬„ä½è¨ˆç®—ç¶²æ ¼
                    currentSelectionFloorMeta = null;
                    updateGrid();
                });
            });
            
            function updateGrid() {
                if (!ctx || !floorplanImage) return;
                
                let width = 0;
                let height = 0;
                let gridSize = 1;

                // è‹¥æœ‰é¸å®šæ¨“å±¤ï¼ˆç·¨è¼¯ç¾æœ‰æ¨“å±¤æ™‚ï¼‰ï¼Œä»¥è©²æ¨“å±¤ DB ä¸­çš„å°ºå¯¸ç‚ºä¸»
                if (currentSelectionFloorMeta) {
                    width = currentSelectionFloorMeta.width || 0;
                    height = currentSelectionFloorMeta.height || 0;
                    gridSize = currentSelectionFloorMeta.gridSize || 1;
                } else {
                    // å»ºç«‹æ–°å±•è¦½ / æ–°ä¸Šå‚³ F001 æ™‚ï¼Œä½¿ç”¨è¡¨å–®è¼¸å…¥çš„å€¼
                    width = parseFloat(floorWidthInput.value) || 0;
                    height = parseFloat(floorHeightInput.value) || 0;
                    gridSize = parseFloat(floorGridInput.value) || 1;
                }
                
                if (width > 0 && height > 0 && gridSize > 0) {
                    // è¨ˆç®—ç¶²æ ¼æ•¸é‡
                    const cols = Math.floor(width / gridSize);
                    const rows = Math.floor(height / gridSize);
                    
                    // è¨ˆç®—æ¯å€‹æ ¼å­åœ¨ canvas ä¸Šçš„å°ºå¯¸
                    const cellWidth = canvas.width / cols;
                    const cellHeight = canvas.height / rows;
                    
                    gridData = { cols, rows, cellWidth, cellHeight };
                    
                    // é‡æ–°ç¹ªè£½åœ–ç‰‡å’Œç¶²æ ¼
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(floorplanImage, 0, 0, canvas.width, canvas.height);
                    
                    // ç¹ªè£½ç¶²æ ¼ç·š
                    ctx.strokeStyle = 'rgba(102, 126, 234, 0.3)';
                    ctx.lineWidth = 1;
                    
                    for (let col = 0; col <= cols; col++) {
                        const x = col * cellWidth;
                        ctx.beginPath();
                        ctx.moveTo(x, 0);
                        ctx.lineTo(x, canvas.height);
                        ctx.stroke();
                    }
                    
                    for (let row = 0; row <= rows; row++) {
                        const y = row * cellHeight;
                        ctx.beginPath();
                        ctx.moveTo(0, y);
                        ctx.lineTo(canvas.width, y);
                        ctx.stroke();
                    }
                    
                    // ç¹ªè£½æ‰€æœ‰å·²é¸æ“‡çš„å€åŸŸ
                    drawAllAreas();
                    
                    // å¦‚æœæœ‰æ­£åœ¨ç¹ªè£½çš„å€åŸŸï¼Œä¹Ÿç¹ªè£½
                    if (selectionMode === 'rect' && rectStartPoint && rectEndPoint) {
                        drawRect();
                    } else if (selectionMode === 'polygon' && polygonPoints.length > 0) {
                        drawPolygon();
                    }
                    
                    // é«˜äº®é¡¯ç¤ºç¶²æ ¼
                    highlightCells();
                }
            }
            
            // é‡ç½®é¸æ“‡ç‹€æ…‹
            function resetSelection() {
                isSelecting = false;
                selectionMode = null;
                polygonPoints = [];
                rectStartPoint = null;
                rectEndPoint = null;
                isDrawingRect = false;
                selectedAreas = [];
                selectionPolygonInput.value = '';
                rectToolBtn.style.display = 'inline-block';
                polygonToolBtn.style.display = 'inline-block';
                undoLastPointBtn.style.display = 'none';
                clearSelectionBtn.style.display = 'none';
                finishSelectionBtn.style.display = 'none';
                finishAllBtn.style.display = 'none';
                selectedAreasList.style.display = 'none';
                selectedAreasTags.innerHTML = '';
                selectionStatus.textContent = '';
                helpText.textContent = '{{ _("é¸æ“‡å·¥å…·ï¼šçŸ©å½¢é¸æ“‡ï¼ˆæ‹–æ‹½ç¹ªè£½çŸ©å½¢ï¼‰æˆ–å¤šé‚Šå½¢é¸æ“‡ï¼ˆé»æ“Šå¤šå€‹é»ï¼‰ã€‚å¯ä»¥æ·»åŠ å¤šå€‹å€åŸŸï¼Œåœˆé¸å€åŸŸå¤–çš„ç¶²æ ¼å°‡è¢«æ¨™è¨˜ç‚ºç„¡æ•ˆã€‚") }}';
                canvas.style.cursor = 'default';
                
                if (ctx && floorplanImage) {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(floorplanImage, 0, 0, canvas.width, canvas.height);
                    updateGrid();
                }
            }
            
            // çŸ©å½¢é¸æ“‡å·¥å…·
            rectToolBtn.addEventListener('click', function() {
                selectionMode = 'rect';
                isSelecting = true;
                polygonPoints = [];
                rectStartPoint = null;
                rectEndPoint = null;
                rectToolBtn.style.display = 'none';
                polygonToolBtn.style.display = 'none';
                clearSelectionBtn.style.display = 'inline-block';
                selectionStatus.textContent = '{{ _("æŒ‰ä½æ»‘é¼ å·¦éµä¸¦æ‹–æ‹½ä¾†ç¹ªè£½çŸ©å½¢") }}';
                helpText.textContent = '{{ _("æŒ‰ä½æ»‘é¼ å·¦éµä¸¦æ‹–æ‹½ä¾†ç¹ªè£½çŸ©å½¢é¸æ“‡å€åŸŸ") }}';
                canvas.style.cursor = 'crosshair';
            });
            
            // å¤šé‚Šå½¢é¸æ“‡å·¥å…·
            polygonToolBtn.addEventListener('click', function() {
                selectionMode = 'polygon';
                isSelecting = true;
                polygonPoints = [];
                rectToolBtn.style.display = 'none';
                polygonToolBtn.style.display = 'none';
                undoLastPointBtn.style.display = 'inline-block';
                clearSelectionBtn.style.display = 'inline-block';
                finishSelectionBtn.style.display = 'inline-block';
                selectionStatus.textContent = '{{ _("é»æ“Šå¹³é¢åœ–ä¸Šçš„é»ä¾†ç¹ªè£½å¤šé‚Šå½¢ï¼Œé»æ“Šã€Œå®Œæˆåœˆé¸ã€å®Œæˆï¼ˆè‡³å°‘3å€‹é»ï¼‰") }}';
                helpText.textContent = '{{ _("é»æ“Šå¹³é¢åœ–ä¸Šçš„é»ä¾†ç¹ªè£½å¤šé‚Šå½¢ï¼Œå¯ä»¥æ·»åŠ ä»»æ„æ•¸é‡çš„é»ï¼Œè‡³å°‘éœ€è¦3å€‹é»æ‰èƒ½å®Œæˆåœˆé¸") }}';
                canvas.style.cursor = 'crosshair';
            });
            
            // æ’¤éŠ·æœ€å¾Œä¸€é»
            undoLastPointBtn.addEventListener('click', function() {
                if (polygonPoints.length > 0) {
                    polygonPoints.pop();
                    if (ctx && floorplanImage) {
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        ctx.drawImage(floorplanImage, 0, 0, canvas.width, canvas.height);
                        updateGrid();
                        drawPolygon();
                    }
                    selectionStatus.textContent = `{{ _("å·²æ·»åŠ ") }} ${polygonPoints.length} {{ _("å€‹é»") }}`;
                }
            });
            
            // å®Œæˆåœˆé¸
            finishSelectionBtn.addEventListener('click', function() {
                if (polygonPoints.length < 3) {
                    selectionStatus.textContent = '{{ _("è‡³å°‘éœ€è¦3å€‹é»æ‰èƒ½å®Œæˆåœˆé¸") }}';
                    return;
                }
                finishSelection();
            });
            
            // æ¸…é™¤åœˆé¸
            clearSelectionBtn.addEventListener('click', resetSelection);
            
            // å®Œæˆæ‰€æœ‰åœˆé¸
            finishAllBtn.addEventListener('click', finishAllSelection);
            
            // å®Œæˆç•¶å‰å€åŸŸï¼ˆæ·»åŠ åˆ°åˆ—è¡¨ä¸­ï¼Œå¯ä»¥ç¹¼çºŒæ·»åŠ æ›´å¤šå€åŸŸï¼‰
            function finishSelection() {
                let polygonData = [];
                let areaType = null;
                
                if (selectionMode === 'rect' && rectStartPoint && rectEndPoint) {
                    // å°‡çŸ©å½¢è½‰æ›ç‚ºå¤šé‚Šå½¢ï¼ˆ4å€‹é ‚é»ï¼‰
                    const x1 = Math.min(rectStartPoint.x, rectEndPoint.x);
                    const y1 = Math.min(rectStartPoint.y, rectEndPoint.y);
                    const x2 = Math.max(rectStartPoint.x, rectEndPoint.x);
                    const y2 = Math.max(rectStartPoint.y, rectEndPoint.y);
                    
                    polygonData = [
                        { x: x1 / canvas.width, y: y1 / canvas.height },
                        { x: x2 / canvas.width, y: y1 / canvas.height },
                        { x: x2 / canvas.width, y: y2 / canvas.height },
                        { x: x1 / canvas.width, y: y2 / canvas.height }
                    ];
                    areaType = 'rect';
                } else if (selectionMode === 'polygon' && polygonPoints.length >= 3) {
                    // å¤šé‚Šå½¢åº§æ¨™ï¼ˆç›¸å°æ–¼åœ–ç‰‡å°ºå¯¸çš„æ¯”ä¾‹ï¼‰
                    polygonData = polygonPoints.map(p => ({
                        x: p.x / canvas.width,
                        y: p.y / canvas.height
                    }));
                    areaType = 'polygon';
                }
                
                if (polygonData.length >= 3) {
                    // æ·»åŠ åˆ°å·²é¸æ“‡å€åŸŸåˆ—è¡¨
                    selectedAreas.push({
                        type: areaType,
                        points: polygonData,
                        id: Date.now() // ç”¨æ–¼è­˜åˆ¥å’Œåˆªé™¤
                    });
                    
                    // æ›´æ–°å€åŸŸåˆ—è¡¨é¡¯ç¤º
                    updateSelectedAreasList();
                    
                    // é‡ç½®ç•¶å‰é¸æ“‡ç‹€æ…‹ï¼Œå…è¨±ç¹¼çºŒæ·»åŠ 
                    isSelecting = false;
                    selectionMode = null;
                    polygonPoints = [];
                    rectStartPoint = null;
                    rectEndPoint = null;
                    isDrawingRect = false;
                    
                    // é‡æ–°ç¹ªè£½æ‰€æœ‰å€åŸŸ
                    if (ctx && floorplanImage) {
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        ctx.drawImage(floorplanImage, 0, 0, canvas.width, canvas.height);
                        updateGrid();
                        drawAllAreas();
                        highlightCells();
                    }
                    
                    // é¡¯ç¤ºå·¥å…·æŒ‰éˆ•
                    rectToolBtn.style.display = 'inline-block';
                    polygonToolBtn.style.display = 'inline-block';
                    undoLastPointBtn.style.display = 'none';
                    finishSelectionBtn.style.display = 'none';
                    finishAllBtn.style.display = 'inline-block';
                    selectedAreasList.style.display = 'block';
                    
                    selectionStatus.textContent = `{{ _("å·²æ·»åŠ ") }} ${selectedAreas.length} {{ _("å€‹å€åŸŸ") }}ï¼Œ{{ _("å¯ä»¥ç¹¼çºŒæ·»åŠ æ›´å¤šå€åŸŸæˆ–é»æ“Šã€Œå®Œæˆæ‰€æœ‰åœˆé¸ã€") }}`;
                    canvas.style.cursor = 'default';
                }
            }
            
            // å®Œæˆæ‰€æœ‰é¸æ“‡ï¼ˆåˆä½µæ‰€æœ‰å€åŸŸä¸¦ä¿å­˜ï¼‰
            function finishAllSelection() {
                if (selectedAreas.length === 0) {
                    selectionStatus.textContent = '{{ _("è«‹è‡³å°‘æ·»åŠ ä¸€å€‹å€åŸŸ") }}';
                    return;
                }
                
                // åˆä½µæ‰€æœ‰å€åŸŸçš„é»ï¼ˆç”¨æ–¼ä¿å­˜ï¼Œå¾Œç«¯æœƒè™•ç†å¤šå€‹å€åŸŸï¼‰
                // é€™è£¡æˆ‘å€‘ä¿å­˜æ‰€æœ‰å€åŸŸçš„æ•¸æ“š
                const allAreasData = selectedAreas.map(area => ({
                    type: area.type,
                    points: area.points
                }));
                
                selectionPolygonInput.value = JSON.stringify(allAreasData);
                
                // æœ€çµ‚é«˜äº®
                highlightCells();
                
                selectionStatus.textContent = `{{ _("å·²å®Œæˆ") }} ${selectedAreas.length} {{ _("å€‹å€åŸŸçš„åœˆé¸") }}`;
                finishAllBtn.style.display = 'none';
            }
            
            // æ›´æ–°å·²é¸æ“‡å€åŸŸåˆ—è¡¨é¡¯ç¤º
            function updateSelectedAreasList() {
                selectedAreasTags.innerHTML = '';
                selectedAreas.forEach((area, index) => {
                    const tag = document.createElement('div');
                    tag.style.cssText = 'display: inline-flex; align-items: center; gap: 5px; background: #667eea; color: white; padding: 5px 10px; border-radius: 4px; font-size: 12px;';
                    tag.innerHTML = `
                        <span>${area.type === 'rect' ? '{{ _("çŸ©å½¢") }}' : '{{ _("å¤šé‚Šå½¢") }}'} ${index + 1}</span>
                        <button type="button" onclick="removeArea(${area.id})" style="background: rgba(255,255,255,0.3); border: none; color: white; cursor: pointer; padding: 2px 6px; border-radius: 3px;">Ã—</button>
                    `;
                    selectedAreasTags.appendChild(tag);
                });
            }
            
            // åˆªé™¤å€åŸŸ
            window.removeArea = function(areaId) {
                selectedAreas = selectedAreas.filter(area => area.id !== areaId);
                updateSelectedAreasList();
                
                if (selectedAreas.length === 0) {
                    selectedAreasList.style.display = 'none';
                    finishAllBtn.style.display = 'none';
                    selectionPolygonInput.value = '';
                }
                
                // é‡æ–°ç¹ªè£½
                if (ctx && floorplanImage) {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(floorplanImage, 0, 0, canvas.width, canvas.height);
                    updateGrid();
                    drawAllAreas();
                    highlightCells();
                }
                
                selectionStatus.textContent = `{{ _("å·²åˆªé™¤ï¼Œå‰©é¤˜") }} ${selectedAreas.length} {{ _("å€‹å€åŸŸ") }}`;
            };
            
            // ç¹ªè£½æ‰€æœ‰å·²é¸æ“‡çš„å€åŸŸ
            function drawAllAreas() {
                selectedAreas.forEach(area => {
                    if (area.type === 'rect') {
                        // çŸ©å½¢å€åŸŸ
                        const points = area.points.map(p => ({
                            x: p.x * canvas.width,
                            y: p.y * canvas.height
                        }));
                        if (points.length === 4) {
                            ctx.strokeStyle = '#667eea';
                            ctx.fillStyle = 'rgba(102, 126, 234, 0.2)';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(points[0].x, points[0].y);
                            for (let i = 1; i < points.length; i++) {
                                ctx.lineTo(points[i].x, points[i].y);
                            }
                            ctx.closePath();
                            ctx.fill();
                            ctx.stroke();
                        }
                    } else if (area.type === 'polygon') {
                        // å¤šé‚Šå½¢å€åŸŸ
                        const points = area.points.map(p => ({
                            x: p.x * canvas.width,
                            y: p.y * canvas.height
                        }));
                        if (points.length >= 3) {
                            ctx.strokeStyle = '#667eea';
                            ctx.fillStyle = 'rgba(102, 126, 234, 0.2)';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(points[0].x, points[0].y);
                            for (let i = 1; i < points.length; i++) {
                                ctx.lineTo(points[i].x, points[i].y);
                            }
                            ctx.closePath();
                            ctx.fill();
                            ctx.stroke();
                            
                            // ç¹ªè£½é ‚é»
                            ctx.fillStyle = '#667eea';
                            points.forEach(p => {
                                ctx.beginPath();
                                ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                                ctx.fill();
                            });
                        }
                    }
                });
            }
            
            // Canvas äº‹ä»¶è™•ç†
            // çŸ©å½¢é¸æ“‡ï¼šæ‹–æ‹½ç¹ªè£½
            canvas.addEventListener('mousedown', function(e) {
                if (!isSelecting || selectionMode !== 'rect') return;
                
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                rectStartPoint = { x, y };
                rectEndPoint = { x, y };
                isDrawingRect = true;
                canvas.style.cursor = 'crosshair';
            });
            
            canvas.addEventListener('mousemove', function(e) {
                if (!isDrawingRect || !rectStartPoint) return;
                
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                rectEndPoint = { x, y };
                
                // é‡æ–°ç¹ªè£½ï¼ˆåŒ…å«å¯¦æ™‚çŸ©å½¢é è¦½å’Œå·²é¸æ“‡çš„å€åŸŸï¼‰
                if (ctx && floorplanImage) {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(floorplanImage, 0, 0, canvas.width, canvas.height);
                    updateGrid();
                    drawAllAreas();
                    drawRect();
                    highlightCells();
                }
            });
            
            canvas.addEventListener('mouseup', function(e) {
                if (!isDrawingRect || !rectStartPoint) return;
                
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                rectEndPoint = { x, y };
                isDrawingRect = false;
                
                // å®ŒæˆçŸ©å½¢é¸æ“‡
                finishSelection();
            });
            
            // å¤šé‚Šå½¢é¸æ“‡ï¼šé»æ“Šæ·»åŠ é»
            canvas.addEventListener('click', function(e) {
                if (!isSelecting || selectionMode !== 'polygon') return;
                
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // ç¢ºä¿åº§æ¨™åœ¨ Canvas ç¯„åœå…§
                const clampedX = Math.max(0, Math.min(x, canvas.width));
                const clampedY = Math.max(0, Math.min(y, canvas.height));
                
                polygonPoints.push({ x: clampedX, y: clampedY });
                
                // æ›´æ–°ç‹€æ…‹é¡¯ç¤º
                selectionStatus.textContent = `{{ _("å·²æ·»åŠ ") }} ${polygonPoints.length} {{ _("å€‹é»") }}ï¼Œ{{ _("é»æ“Šã€Œå®Œæˆåœˆé¸ã€å®Œæˆï¼ˆè‡³å°‘éœ€è¦3å€‹é»ï¼‰") }}`;
                
                // é‡æ–°ç¹ªè£½
                if (ctx && floorplanImage) {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(floorplanImage, 0, 0, canvas.width, canvas.height);
                    updateGrid();
                    drawPolygon();
                }
            });
            
            // ç¹ªè£½çŸ©å½¢
            function drawRect() {
                if (!rectStartPoint || !rectEndPoint) return;
                
                const x1 = Math.min(rectStartPoint.x, rectEndPoint.x);
                const y1 = Math.min(rectStartPoint.y, rectEndPoint.y);
                const x2 = Math.max(rectStartPoint.x, rectEndPoint.x);
                const y2 = Math.max(rectStartPoint.y, rectEndPoint.y);
                
                ctx.strokeStyle = '#667eea';
                ctx.fillStyle = 'rgba(102, 126, 234, 0.2)';
                ctx.lineWidth = 2;
                
                ctx.fillRect(x1, y1, x2 - x1, y2 - y1);
                ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);
            }
            
            // ç¹ªè£½å¤šé‚Šå½¢
            function drawPolygon() {
                if (polygonPoints.length < 2) return;
                
                ctx.strokeStyle = '#667eea';
                ctx.fillStyle = 'rgba(102, 126, 234, 0.2)';
                ctx.lineWidth = 2;
                
                ctx.beginPath();
                ctx.moveTo(polygonPoints[0].x, polygonPoints[0].y);
                for (let i = 1; i < polygonPoints.length; i++) {
                    ctx.lineTo(polygonPoints[i].x, polygonPoints[i].y);
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // ç¹ªè£½é ‚é»
                ctx.fillStyle = '#667eea';
                polygonPoints.forEach(p => {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                    ctx.fill();
                });
            }
            
            // åˆ¤æ–·é»æ˜¯å¦åœ¨å¤šé‚Šå½¢å…§ï¼ˆå°„ç·šæ³•ï¼‰
            function pointInPolygon(point, polygon) {
                let inside = false;
                for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                    const xi = polygon[i].x, yi = polygon[i].y;
                    const xj = polygon[j].x, yj = polygon[j].y;
                    const intersect = ((yi > point.y) !== (yj > point.y)) &&
                        (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);
                    if (intersect) inside = !inside;
                }
                return inside;
            }
            
            // é«˜äº®é¡¯ç¤ºæœ‰æ•ˆå’Œç„¡æ•ˆçš„ç¶²æ ¼
            function highlightCells() {
                if (!gridData) return;
                
                // æ”¶é›†æ‰€æœ‰å€åŸŸçš„å¤šé‚Šå½¢ï¼ˆåŒ…æ‹¬ç•¶å‰æ­£åœ¨ç¹ªè£½çš„ï¼‰
                const allPolygons = [];
                
                // æ·»åŠ å·²å®Œæˆçš„å€åŸŸ
                selectedAreas.forEach(area => {
                    const canvasPolygon = area.points.map(p => ({
                        x: p.x * canvas.width,
                        y: p.y * canvas.height
                    }));
                    if (canvasPolygon.length >= 3) {
                        allPolygons.push(canvasPolygon);
                    }
                });
                
                // æ·»åŠ ç•¶å‰æ­£åœ¨ç¹ªè£½çš„å€åŸŸ
                if (selectionMode === 'rect' && rectStartPoint && rectEndPoint) {
                    const x1 = Math.min(rectStartPoint.x, rectEndPoint.x);
                    const y1 = Math.min(rectStartPoint.y, rectEndPoint.y);
                    const x2 = Math.max(rectStartPoint.x, rectEndPoint.x);
                    const y2 = Math.max(rectStartPoint.y, rectEndPoint.y);
                    
                    allPolygons.push([
                        { x: x1, y: y1 },
                        { x: x2, y: y1 },
                        { x: x2, y: y2 },
                        { x: x1, y: y2 }
                    ]);
                } else if (selectionMode === 'polygon' && polygonPoints.length >= 3) {
                    allPolygons.push(polygonPoints.map(p => ({ x: p.x, y: p.y })));
                }
                
                // è‹¥æ²’æœ‰å¤šé‚Šå½¢ï¼ˆå‰›é€²ç·¨è¼¯é å°šæœªé‡æ–°åœˆé¸ï¼‰ï¼Œå°±ç”¨ç›®å‰ DB çš„å•Ÿç”¨ç‹€æ…‹ä¾†é‚„åŸç¯„åœ
                let activeCellSet = null;
                const currentFloorCode = selectionFloorHidden ? selectionFloorHidden.value : null;
                if (allPolygons.length === 0 && currentFloorCode && floorCellsMap[currentFloorCode]) {
                    activeCellSet = new Set();
                    floorCellsMap[currentFloorCode].forEach(c => {
                        if (c.is_active) {
                            activeCellSet.add(`${c.row},${c.col}`);
                        }
                    });
                }
                
                // æª¢æŸ¥æ¯å€‹ç¶²æ ¼çš„ä¸­å¿ƒé»ï¼š
                // - è‹¥æœ‰å¤šé‚Šå½¢ï¼Œä»¥å¤šé‚Šå½¢è¨ˆç®— inside
                // - å¦å‰‡è‹¥æœ‰ activeCellSetï¼Œä»¥ DB is_active ç‚ºæº–
                for (let row = 0; row < gridData.rows; row++) {
                    for (let col = 0; col < gridData.cols; col++) {
                        const centerX = (col + 0.5) * gridData.cellWidth;
                        const centerY = (row + 0.5) * gridData.cellHeight;
                        
                        let isInside = false;
                        if (allPolygons.length > 0) {
                            // æª¢æŸ¥é»æ˜¯å¦åœ¨ä»»ä½•ä¸€å€‹å€åŸŸå…§
                            for (const polygon of allPolygons) {
                                if (pointInPolygon({ x: centerX, y: centerY }, polygon)) {
                                    isInside = true;
                                    break;
                                }
                            }
                        } else if (activeCellSet) {
                            isInside = activeCellSet.has(`${row},${col}`);
                        } else {
                            // æ²’æœ‰ä»»ä½•è³‡è¨Šæ™‚ï¼Œä¸åšä¸Šè‰²
                            continue;
                        }
                        
                        // ç¹ªè£½ç¶²æ ¼èƒŒæ™¯è‰²
                        ctx.fillStyle = isInside 
                            ? 'rgba(46, 204, 113, 0.1)' 
                            : 'rgba(231, 76, 60, 0.2)';
                        ctx.fillRect(
                            col * gridData.cellWidth,
                            row * gridData.cellHeight,
                            gridData.cellWidth,
                            gridData.cellHeight
                        );
                    }
                }
                
                // é‡æ–°ç¹ªè£½ç¶²æ ¼ç·š
                ctx.strokeStyle = 'rgba(102, 126, 234, 0.3)';
                ctx.lineWidth = 1;
                
                for (let col = 0; col <= gridData.cols; col++) {
                    const x = col * gridData.cellWidth;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                    ctx.stroke();
                }
                
                for (let row = 0; row <= gridData.rows; row++) {
                    const y = row * gridData.cellHeight;
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }
                
                // é‡æ–°ç¹ªè£½æ‰€æœ‰å€åŸŸ
                drawAllAreas();
                
                // ç¹ªè£½ç•¶å‰æ­£åœ¨ç¹ªè£½çš„å€åŸŸ
                if (selectionMode === 'rect' && rectStartPoint && rectEndPoint) {
                    drawRect();
                } else if (selectionMode === 'polygon' && polygonPoints.length > 0) {
                    drawPolygon();
                }
            }
        })();
    </script>
</body>
</html>
